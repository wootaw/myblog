---
layout: post
title:  "编写高效的CSS选择器"
date:   2011-10-03 20:11:43 +0800
categories: css
---
高效的CSS不是一个新主题，也不是我真正需要涵盖的主题，但它是我真正感兴趣的东西，并且自从在Sky工作以来一直在关注越来越多。

许多人忘记了，或者根本没有意识到，CSS可以写得高性能也可以很低性能。这可以很容易地原谅，但是当你意识到你可以做多少，错误，意识到，非高效的CSS。

这些规则仅适用于速度为特征的高性能网站，并且任何给定页面上都可以显示1000个DOM元素。但最佳实践就是最佳实践，无论您是构建下一个Facebook，还是本地装饰的网站，都应该知道这些...

## CSS选择器

CSS选择器对我们大多数人来说都不是新的概念，基本的选择器类型分别是（例如 **div**），ID（例如 **#header**）和类（例如 **.tweet**）。

更常见的包括基本的伪类（例如 **:hover**）和更复杂的CSS3和“正则表达式”选择器，例如 **:first-child** 或 **[class^="grid-"]**。

选择器具有固有的效率，引用史蒂夫·索德斯（Steve Souders），因此选择效率较高的CSS选择器的顺序如下：

- ID, 例如 **#header**
- Class, 例如 **.promo**
- Type, 例如 **div**
- Adjacent sibling, 例如 **h2 + p**
- Child, 例如 **li > ul**
- Descendant, 例如 **ul a**
- Universal, 例如 *
- Attribute, 例如 **[type="text"]**
- Pseudo-classes/-elements, 例如 **a:hover**

值得注意的是，虽然ID在技术上更快，性能更高，但几乎没有。使用Steve Souders的CSS Test Creator，我们可以看到ID选择器和类选择器在 reflow 速度上的差异非常小。

在Windows机器上的Firefox 6中，对于简单的类选择器，我得到的平均reflow数为10.9。 ID选择器的平均值为12.5，因此实际上reflow慢于类选择器。

__ID和类之间的速度差异几乎完全无关紧要。__

选择类型（** <a> **）而不是类或ID的测试给出了更慢的回流。

对严重过度资格的后代选择器的测试给出了大约440的数字！

由此可以看出，ID /类和类型/后代之间的差异相当大......它们之间的差异很小。

注：这些数字可以在机器和浏览器之间大量变化。我强烈建议你自己测试一下。

## 组合选择器

您可以使用**#nav**这样的独立选择器，它将选择ID为“nav”的任何元素，或者您可以使用组合选择器，例如**#nav a**，它将匹配ID为“nav”的任何元素中的任何锚点。

现在，我们从左往右阅读这些内容。我们看到我们正在寻找**#nav**，然后是那里的任何元素。浏览器则以不同的方式阅读：**浏览器从右往左读取选择器**。

在我们看到带有a的**#nav**的地方，浏览器会在**#nav**中看到a。这种微妙的差异对选择器性能产生巨大影响，是一个非常有价值的东西。

有关他们为何这样做的深入原因，请参阅[Stack Overflow](https://stackoverflow.com/questions/5797014/why-do-browsers-match-css-selectors-from-right-to-left)上的讨论。

浏览器从最右边的元素（它知道它要设置样式的元素）开始并以更高效的方式重新启动DOM树，而不是从DOM树开始向上并沿着可能的行程向下移动 甚至不是最右边的选择器 - 也称为键选择器。

这对CSS选择器的性能有非常重要的影响......

## 键选择器

如上所述，键选择器是较大的CSS选择器的最右侧部分。这是浏览器首先要查找的内容。

还记得那里我们讨论过哪种类型的选择器性能最高？无论哪一个是键选择器都会影响选择器的性能;在编写高效的CSS时，这个键选择器可以保持高性能匹配。

像这样的键选择器：

```css
#content .intro {}
```

由于类本身就是一个高性能的选择器，因此可能非常高效。浏览器将查找.intro的所有实例（其中可能不会有很多），然后查找DOM树以查看匹配的键选择器是否存在于ID为“content”的元素中。

但是，以下选择器根本不具备高性能：

```css
#content * {}
```

它的作用是查看页面上的每个元素（即每一个元素），然后查看是否有任何元素存在于#content父元素中。这是一个非常不具备性能的选择器，因为键选择器非常昂贵。

利用这些知识，我们可以更好地决定我们的元素分类和选择。

假设你有一个庞大的页面，它是巨大的，你是一个大的，大的网站。在那个页面上有数百甚至数千个<a>。在<ul>中还有一小部分社交媒体链接，ID为#social;假设有Twitter，Facebook，Dribbble和Google+链接。我们在此页面上有四个社交媒体链接，还有数百个其他锚点。

因此，这个选择器非常昂贵且性能不高：

```css
#social a {}
```

这里将会发生的事情是，在确定#social部分的四个内部之前，浏览器将评估该页面上的所有数千个链接。我们的键选择器匹配了太多我们不感兴趣的其他元素。

为了解决这个问题，我们可以为社交区域中的每个<a>添加更具体和明确的.social-link选择器。但这违背了我们所知道的;当我们可以使用（c）更精简的标记时，我们知道不要在元素上放置不必要的类。

这就是我发现表演如此有趣的原因;这是Web标准最佳实践和纯粹速度之间的奇怪平衡。

而我们通常会：

```html
<ul id="social">
  <li><a href="#" class="twitter">Twitter</a></li>
  <li><a href="#" class="facebook">Facebook</a></li>
  <li><a href="#" class="dribble">Dribbble</a></li>
  <li><a href="#" class="gplus">Google+</a></li>
</ul>
```

用这个CSS：

```css
#social a {}
```

我们现在有：

```html
<ul id="social">
  <li><a href="#" class="social-link twitter">Twitter</a></li>
  <li><a href="#" class="social-link facebook">Facebook</a></li>
  <li><a href="#" class="social-link dribble">Dribbble</a></li>
  <li><a href="#" class="social-link gplus">Google+</a></li>
</ul>
```

用这个CSS：

```css
#social .social-link {}
```

这个新的键选择器将匹配更少的元素，这意味着浏览器可以找到它们并更快地设置它们，并可以继续下一步。

并且，我们实际上可以通过不过度限定它来将此选择器进一步降低到.social-link {};请继续阅读下一节...

因此，回顾一下，您的密钥选择器是确定浏览器必须完成多少工作的密钥选择器，因此这是一个值得关注的选择器。

## 资格过高的选择者

好的，现在我们知道关键选择器是什么，而且这是大部分工作的来源，我们可以进一步优化。拥有好的显式键选择器的最好的事情是你经常可以避免选择器过度限定。一个资格过高的选择器可能如下所示：

html body .wrapper #content a {}

这里发生了太多事情，至少有三个选择器是完全没必要的。这最多可能是这样的：

```css
#content a {}
```

所以呢？

那么第一个意味着浏览器必须查找所有元素，然后检查它们是否在ID为“content”的元素中，然后依此类推，直到html为止。这导致浏览器太多我们真正不需要的检查。知道了这一点，我们可以得到更实际的例子：

```css
#nav li a {}
```

直到：

```css
#nav a {}
```

我们知道如果a在li里面，它必须在#nav中，所以我们可以立即从选择器中删除li。然后，由于导航具有ID，我们知道页面中只存在一个ID，因此应用它的元素完全无关紧要;我们也可以放弃ul。过度合格的选择器使浏览器比它需要的更加努力并耗尽它的时间;通过减少不必要的比特，使你的选择器更精简，更高效。

## 这一切真的有必要吗？

简短的回答是;可能不是。

答案越长;这取决于你正在建设的网站。如果您正在处理下一个产品组合，那么请选择干净的代码而不是CSS选择器性能，因为您真的不太可能注意到它。

如果您正在构建下一个亚马逊，那么页面速度的微秒确实会有所不同，但即便如此也许不是。

浏览器只会在CSS解析速度上变得更好，甚至是移动的。您不太可能注意到网站上的CSS选择器速度慢但是......

## 但是

它仍在发生，浏览器仍然必须完成我们所讨论的所有工作，无论它们有多快。即使你不需要甚至不想实现任何这一点，它也是绝对值得了解的。请记住，选择器可能很昂贵，你应该尽可能避免使用更明显的选择器。这意味着如果你发现自己写的东西如下：

```css
div:nth-of-type(3) ul:last-child li:nth-of-type(odd) * { font-weight:bold }
```

然后你可能做错了。

现在，我仍然对选择器效率的世界有点新意，所以如果我错过了任何东西，或者你有什么要补充的，请在评论中弹出它！

## 更多关于CSS选择器的效率

我不能推荐[Steve Souders](http://stevesouders.com/)的网站和书籍。这几乎是您需要的所有进一步阅读建议。那家伙知道他的东西！
